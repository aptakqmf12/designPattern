# 반복자 패턴

- 일련의 데이터 집합(List, Array, HashMap, Tree... 등등)에 대해 순차적인 접근(순회)를 지원하는 패턴.
- 배열이나 리스트는 연속적인 데이터라 for문을 통해 순회가능하지만, 해시,트리같이 순서가 정해지지않은 데이터타입은 접근방식이 애매하다. (깊이우선? 너비우선?)
- 그래서 이런 컬렉션 자료구조를 순회하는 전략을 정의하는게 반복자 패턴임.

## 사용시기

- 컬렉션에 상관없이 순회방식을 통일하고자할때
- 컬렉션 순회하는 다양한 방법을 지원하고자할때
- 복잡한 컬렉션의 내부 구조를 캡슐화
- 컬렉션의 종류가 바뀔 가능성이 있을때

## 장점

- 일관된 `Iterator` 인터페이스를 통해 동일한 순회방법을 제공함.
- 컬렉션 내부 구조를 몰라도됨
- 순회 알고리즘을 별도로 분리해서 SRP (단일책임)을 준수
- 컬렉션의 종류가 바뀌어도 구현코드는 변경되지않아 OCP (개방폐쇄)를 준수

## 단점

- class가 늘어나 복잡함

<br/><br/><br/><br/><br/>

# 컴포지트 패턴

- 복합객체(Composite)와 단일객체(Leaf)를 동일한 컴포넌트로 취급하여 단순화 시키고 클라이언트에게 이 둘을 구분하지않고 동일한 인터페이스를 사용하도록 하는 패턴.
  - composite는 윈도우의 폴더(내부에 composite나 leaf가 있을수있고 없을수도있다)로 이해하기 좋고, leaf(종점이다)는 파일로 이해하면 된다
  - 전체-부분의 관계를 갖는 트리 계층 구조를 정의할때 유용함
- 복잡한 구조를 재귀동작을 통해 하위객체에 작업을 위임함.

![Alt text](image.png)

## 사용시기

- 데이터를 계층적으로 표현해야할때
- 복잡한 객체관계를 단순화 하여 표현하고싶을때

## 장점

- composite와 leaf가 동일하게 여겨져서 연산, 관리가 편리함
- 다형성 재귀를 통해 복잡한 트리구조를 편리하게 구성가능
- 수평, 수직 모든 방향으로 확장 가능
- 새로운 leaf를 추가해도 클라이언트에선 추상화된 인터페이스만 보기때문에 OCP 준수

## 단점

- 재귀호출 특성상 depth가 깊어지면 디버깅이 어려움
